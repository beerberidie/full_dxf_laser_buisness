# Laser_OS_Production_Automation_Blueprint.md  
(Generated 28 Oct 2025 @ 07:30 SAST)

---

## 1. Executive Summary

Laser OS is evolving from “a dashboard that shows data” into “a production control system that runs the floor.”

This blueprint defines exactly how to implement that behavior in the existing Laser OS stack (Flask, Python 3.11+, SQLite, Windows path:  
`c:\Users\Garas\Documents\augment-projects\full_dxf_laser_buisness`).

Business goals that this release must satisfy:

1. **Production must log itself.**  
   Operators log cutting runs from their phones. That data drives:
   - Inventory deductions (sheet counts down automatically)
   - Efficiency metrics (planned vs actual time)
   - Daily report to management
   - Project stage progression

2. **The system must warn, not just record.**  
   - Low stock
   - Jobs stuck in approval too long
   - Jobs waiting on missing material
   - Finished jobs not yet collected
   - Clients needing follow-up

   These become:
   - Bell icon alerts (attention list)
   - Daily Report (07:30 SAST every morning, plus manual trigger)
   - Draft client comms in Communications (WhatsApp/email style)

3. **Inventory is now real, not theoretical.**  
   - Track physical sheet counts by material, thickness, and sheet size.
   - Deduct sheets on every completed run.
   - Refuse / warn if there’s not enough stock for a project.

4. **Presets become enforced process.**  
   - Each material+thickness maps to a cutting preset record (gas, pressure, etc.).
   - Preset is auto-attached to a job.
   - Operators can view presets in phone mode but cannot edit them.

5. **Status stages become managed, escalated workflow.**  
   - Every Project has a stage (Quotes+Approval / Waiting on material / Cutting / Ready for pickup / Delivered).
   - The system times how long a Project sits in a given stage.
   - If it sits too long, Laser OS raises a notification and generates a ready-to-send follow-up message.

Bottom line:  
This blueprint turns Laser OS into an active production manager that tells you what needs doing today, what is blocked, and what to tell the client — without you having to chase or remember.

---

## 2. Architecture & Affected Modules

### 2.1 Core Modules (from spec)
- Dashboard
- Clients
- Projects
- Products
- Queue
- Presets
- Operators
- Inventory
- Reports
- SAGE
- Communications
- Admin

### 2.2 Modules impacted by this blueprint

**Login / Session Layer**  
- Adds Mode Selector (“PC Mode” vs “Phone Mode”) after login.
- Affects: Dashboard (PC), Operators (Phone view), Security (role).

**Operators Module**  
- Unified with auth. A `User` with role Operator is automatically an Operator record.
- All run logs tie to the authenticated operator.

**Inventory Module**  
- Tracks physical sheets `{material, thickness, size, count, min_required}`.
- Deducts on run completion.
- Feeds:
  - Daily Report → “Material I need to order”
  - Project blocking logic → “Waiting on material”
  - Bell notifications → “low stock”

**Projects / Queue Module**  
- Holds project stage and stage timestamps.
- Marks stage transitions:
  - Waiting on material
  - Cutting
  - Ready for pickup / delivery
  - Delivered / complete
  - Quotes and Approval (pre-cut)
- Drives alerts, client comms, Daily Report sections.

**Presets Module**  
- Maps thickness → machine cut settings.
- Auto-attaches to Projects.
- Read-only in Phone Mode.

**Reports Module**  
Becomes data-backed:
- Production Summary
- Efficiency Metrics
- Inventory Report
- Client & Project Reports
All populated from production run logs, inventory, and project stages.

**Communications Module**  
- Receives autogenerated draft client messages for:
  - Approval follow-up
  - Pickup ready
  - Material delay
- Allows manual send.

**Notifications (Bell)**  
- Central attention list.
- Populated by:
  - Stage overdue
  - Low stock
  - Job ready for pickup
  - Missing client approval
  - Blocked by material

### 2.3 Automation Systems affected
- **Auto-Queue on POP Received** (unchanged logic, but now queue items know material requirement and stock availability).
- **Queue-Project Status Sync** (now escalates stuck states into Notifications).
- **Operator Auto-Bind** (login identity = operator identity for run logs).

### 2.4 High-level data flow

1. Operator in Phone Mode logs a run.  
2. System writes `LaserRun`, deducts `InventoryItem.count`, stamps `Project.stage_time_last_updated`.  
3. Reports and Notifications update.
4. Daily Report generator composes:
   - “What needs to be cut today”
   - “What needs to be ordered”
   - “Who to message”

→ This loop eliminates manual chasing.

---

## 3. Implementation Specs

This section goes feature by feature and defines routes, models, logic, and view behavior.  
Detailed DB schema, API surface, and security are expanded in later sections.

### 3.1 Login Flow & Mode Selection

#### Requirement
After username/password auth, user must explicitly choose:
- **PC Mode** → full dashboard with sidebar.
- **Phone Mode** → operator mobile UI.

#### Implementation

**File:** `app/auth/routes.py`

```python
from flask import Blueprint, render_template, request, redirect, session, url_for
from app.models import User
from app.extensions import db
from flask_login import login_user, current_user

auth_bp = Blueprint("auth", __name__, url_prefix="/auth")

@auth_bp.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "GET":
        return render_template("auth/login.html")  # username/password form

    username = request.form.get("username", "").strip()
    password = request.form.get("password", "").strip()

    user = User.authenticate(username=username, password=password)
    if not user:
        return render_template("auth/login.html", error="Invalid credentials")

    login_user(user)

    # Store identity in session for downstream attribution
    session["operator_id"] = user.id  # used in Phone Mode run logging
    return redirect(url_for("auth.select_mode"))

@auth_bp.route("/select-mode", methods=["GET", "POST"])
def select_mode():
    # GET shows 2 big buttons: PC Mode / Phone Mode
    if request.method == "GET":
        return render_template(
            "auth/select_mode.html",
            user=current_user
        )

    chosen = request.form.get("mode")
    if chosen == "pc":
        session["ui_mode"] = "pc"
        return redirect(url_for("dashboard.pc_home"))
    else:
        session["ui_mode"] = "phone"
        return redirect(url_for("phone.home"))
```

**Key behavior:**
- `session["ui_mode"]` controls which layout wrapper to use.
- `operator_id` in session ties all production logs to the auth’d human.
- No shared “shop floor” generic logins. Each run is traceable.

**UI templates to add:**
- `templates/auth/select_mode.html`
  - Two large tap targets:
    - “PC Mode (Planning / Admin / Inventory / Reporting)”
    - “Phone Mode (Run Logging)”
  - Mobile-friendly.

---

### 3.2 Operators Integration

#### Requirement
- Every authenticated `User` is an Operator record by default.
- Some “extra operators” (who don’t log in to PC) must still exist to attribute runs.

#### Model adjustments (preview; full schema in Section 4)
We unify `User` and `Operator`:

```python
# app/models.py (excerpt)

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)

    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    role = db.Column(db.String(50), nullable=False, default="operator")
    # role choices: "operator", "manager", "admin"

    is_active_operator = db.Column(db.Boolean, nullable=False, default=True)
    display_name = db.Column(db.String(120), nullable=False)

    # relationship: production runs performed by this operator
    runs = db.relationship("LaserRun", back_populates="operator", lazy="dynamic")

    def authenticate(username, password):
        # verify password, return user or None
        ...

class ExtraOperator(db.Model):
    # Represents someone physically running the machine but
    # who does not have full login to PC Mode.
    # They can still be attributed in logs if selected manually.
    __tablename__ = "extra_operators"
    id = db.Column(db.Integer, primary_key=True)
    display_name = db.Column(db.String(120), nullable=False)
    active = db.Column(db.Boolean, nullable=False, default=True)
```

#### Phone Mode run attribution logic:
- Default operator = `session["operator_id"]` (a real User).
- UI still allows override to attribute the run to an `ExtraOperator` instead, if needed (night shift / temp), but we keep the logged-in user ID for audit anyway.

This satisfies:
- “Operators log in as themselves.”
- “Production logs are tied to the current operator.”
- “Must support extra operators who don’t use PC dashboard.”

We will expand full schema in Section 4.

---

### 3.3 Inventory Management (Sheets, not m²)

#### Requirement
- Track stock as physical sheets.
- e.g. “6 sheets of 1.2mm Mild Steel, 3000x1500.”
- Fields:
  - material_type (Mild Steel / Stainless / Galv / etc.)
  - thickness (from controlled list)
  - sheet_size (string like `3000x1500`)
  - count (int)
  - min_required (int threshold)

- When a run is completed in phone mode, decrement Inventory by sheets consumed.
- When approving/creating a project, check required material vs stock and mark block status.

#### Model (preview)

```python
class InventoryItem(db.Model):
    __tablename__ = "inventory_items"

    id = db.Column(db.Integer, primary_key=True)

    material_type = db.Column(db.String(80), nullable=False)
    thickness_mm = db.Column(db.String(10), nullable=False)  # "1.2", "16", etc.
    sheet_size = db.Column(db.String(32), nullable=False)     # "3000x1500"

    count = db.Column(db.Integer, nullable=False, default=0)
    min_required = db.Column(db.Integer, nullable=False, default=0)

    # derived flags - not stored, computed in queries
    # is_low_stock -> count < min_required
```

#### Thickness dropdown enforcement
Authoritative thickness list (from spec):
- 0.47 mm  
- 0.53 mm  
- 1.0 mm  
- 1.2 mm  
- 2.0 mm  
- 2.5 mm  
- 3.0 mm  
- 3.5 mm  
- …standard increments…  
- up to 16 mm

Implementation detail:
- Hard-code this list in a single source of truth: `app/constants/material_thickness.py`.

```python
# app/constants/material_thickness.py
THICKNESS_OPTIONS_MM = [
    "0.47", "0.53", "1.0", "1.2", "2.0", "2.5",
    "3.0", "3.5", "4.0", "5.0", "6.0", "8.0",
    "10.0", "12.0", "16.0"
]
```

All forms pull this list:
- Inventory Add/Edit form.
- Project Material Requirement form.
- Preset definition form.

This guarantees alignment between Inventory, Projects, and Presets.

#### Deducting inventory on run completion

**File:** `app/production/logic.py`

```python
from app.models import InventoryItem, LaserRun, db

def apply_run_inventory_deduction(laser_run: "LaserRun"):
    """
    Deduct sheet stock based on actual usage reported in the run.
    """
    mat = laser_run.material_type
    thick = laser_run.thickness_mm
    size = laser_run.sheet_size
    used_sheets = laser_run.sheets_used

    inv_row = (
        InventoryItem.query
        .filter_by(material_type=mat, thickness_mm=thick, sheet_size=size)
        .first()
    )

    if inv_row:
        inv_row.count = max(inv_row.count - used_sheets, 0)

        db.session.add(inv_row)
        db.session.commit()
```

This function is called when the operator presses “End Run” in phone mode (Section 3.4).

#### Stock check for project approval / scheduling

When a Project is moved into “Cutting” stage or approved for cutting:
- We inspect material requirements vs `InventoryItem.count`.
- If insufficient, Project stage is forced to “Waiting on material.”
- We also generate a Notification (“job is blocked by missing material”) and a Daily Report entry.

Stage logic is expanded in Sections 3.5 and 7.

---

### 3.4 Phone Mode: Production Run Logging

#### Requirement
Phone Mode must let an operator:
- Pick the project/job they’re cutting.
- Start the run (timestamp).
- End the run (timestamp).
- Log how many sheets they actually consumed.
- Optionally note issues (scrap, re-cut, etc.).
- This data must update:
  - Production Summary
  - Efficiency Metrics
  - Inventory deduction
  - Daily Report
  - Project status (if cutting finished)

#### Routes and logic

**Blueprint:** `app/phone/routes.py`

```python
from flask import Blueprint, render_template, request, redirect, session, url_for
from flask_login import login_required, current_user
from datetime import datetime
from app.extensions import db
from app.models import Project, LaserRun
from app.production.logic import apply_run_inventory_deduction
from app.reports.updater import update_reports_after_run
from app.notifications.logic import evaluate_notifications_for_project

phone_bp = Blueprint("phone", __name__, url_prefix="/phone")

@phone_bp.route("/home", methods=["GET"])
@login_required
def home():
    # Show active jobs ready to cut or currently cutting
    # Minimal, thumb-friendly list
    projects = Project.query.filter(Project.stage.in_(["Cutting", "ReadyToCut"])).all()
    return render_template("phone/home.html", projects=projects, operator=current_user)

@phone_bp.route("/run/start", methods=["POST"])
@login_required
def start_run():
    project_id = request.form.get("project_id")
    project = Project.query.get_or_404(project_id)

    run = LaserRun(
        project_id=project.id,
        operator_id=current_user.id,
        started_at=datetime.utcnow(),
        status="running",
        material_type=project.material_type,
        thickness_mm=project.thickness_mm,
        sheet_size=project.sheet_size
    )
    db.session.add(run)

    # mark project stage as Cutting if not already
    if project.stage != "Cutting":
        project.stage = "Cutting"
        project.stage_last_updated = datetime.utcnow()
        db.session.add(project)

    db.session.commit()

    return redirect(url_for("phone.view_run", run_id=run.id))

@phone_bp.route("/run/<int:run_id>", methods=["GET"])
@login_required
def view_run(run_id):
    run = LaserRun.query.get_or_404(run_id)
    return render_template("phone/run_active.html", run=run, operator=current_user)

@phone_bp.route("/run/end", methods=["POST"])
@login_required
def end_run():
    run_id = request.form.get("run_id")
    sheets_used = int(request.form.get("sheets_used", "0"))
    notes = request.form.get("notes", "").strip()

    run = LaserRun.query.get_or_404(run_id)
    run.ended_at = datetime.utcnow()
    run.status = "completed"
    run.sheets_used = sheets_used
    run.notes = notes

    db.session.add(run)
    db.session.commit()

    # deduct physical stock
    apply_run_inventory_deduction(run)

    # update reporting aggregates
    update_reports_after_run(run)

    # evaluate project status + downstream notifications after this run
    evaluate_notifications_for_project(run.project_id)

    return redirect(url_for("phone.home"))
```

#### Key behaviors
- A run always stores:
  - operator_id (who cut)
  - project_id (what job)
  - timestamps start/end
  - sheets_used
  - notes/issues
- On completion:
  - We decrement `InventoryItem.count`
  - We refresh all dependent reports
  - We re-check project stage

This is the heart of “Phone mode is not fluff, it's the production source of truth.”

---

### 3.5 Project Stages & Escalation

#### Requirement
Stages we actively track:
- `QuotesAndApproval`
- `WaitingOnMaterial`
- `Cutting`
- `ReadyForPickup`
- `Delivered`
(“Delivered / complete” has no escalation)

We also need timing and alerts:
- QuotesAndApproval > 4 days → alert + draft client follow-up
- WaitingOnMaterial too long → alert + appears in “Material I need to order”
- Cutting taking too long with no completed run → stall alert
- ReadyForPickup too long → reminder to contact client

#### Model additions (preview; full detail in Section 4)

```python
class Project(db.Model):
    __tablename__ = "projects"
    id = db.Column(db.Integer, primary_key=True)

    client_id = db.Column(db.Integer, db.ForeignKey("clients.id"), nullable=False)

    name = db.Column(db.String(200), nullable=False)

    stage = db.Column(db.String(50), nullable=False, default="QuotesAndApproval")
    stage_last_updated = db.Column(db.DateTime, nullable=False)

    # material requirements for inventory check
    material_type = db.Column(db.String(80), nullable=False)
    thickness_mm = db.Column(db.String(10), nullable=False)
    sheet_size = db.Column(db.String(32), nullable=False)
    sheets_required = db.Column(db.Integer, nullable=False, default=0)

    # timestamps (expected deadline, due date, etc.)
    target_complete_date = db.Column(db.DateTime, nullable=True)
```

#### Stage timing + escalation logic

**File:** `app/notifications/logic.py`

```python
from datetime import datetime, timedelta
from app.models import Project, Notification, db
from app.comms.drafts import build_client_followup_message

STAGE_LIMITS = {
    "QuotesAndApproval": timedelta(days=4),
    "WaitingOnMaterial": timedelta(days=2),
    "Cutting": timedelta(days=1),
    "ReadyForPickup": timedelta(days=2),
    # Delivered has no escalation
}

def evaluate_notifications_for_project(project_id: int):
    project = Project.query.get(project_id)
    if not project:
        return

    now = datetime.utcnow()
    stage = project.stage
    age = now - (project.stage_last_updated or now)

    # Clear resolved notifications for this project first
    Notification.query.filter_by(project_id=project.id, resolved=False).update(
        {"resolved": True, "auto_cleared": True}
    )

    # If stage is Delivered, nothing to raise.
    if stage == "Delivered":
        db.session.commit()
        return

    limit = STAGE_LIMITS.get(stage)
    if limit and age > limit:
        # raise new notification
        note_type, note_msg = _stage_to_notification(stage, project)
        n = Notification(
            project_id=project.id,
            notif_type=note_type,
            message=note_msg,
            resolved=False,
            auto_cleared=False,
        )
        db.session.add(n)

        # Generate draft outgoing message in Communications if client-facing
        if stage in ["QuotesAndApproval", "ReadyForPickup"]:
            draft_txt = build_client_followup_message(project, stage)
            db.session.add(draft_txt)

    db.session.commit()

def _stage_to_notification(stage: str, project: Project):
    if stage == "QuotesAndApproval":
        return (
            "approval_wait",
            f"Follow up with Client {project.client_id} on approval for Project {project.name}."
        )
    if stage == "WaitingOnMaterial":
        return (
            "material_block",
            f"Project {project.name} blocked: missing {project.material_type} {project.thickness_mm}mm {project.sheet_size}."
        )
    if stage == "Cutting":
        return (
            "cutting_stall",
            f"Project {project.name} marked Cutting but no completed run logged recently."
        )
    if stage == "ReadyForPickup":
        return (
            "pickup_wait",
            f"Client has not collected Project {project.name}."
        )
    return ("generic", f"Project {project.name} requires attention.")
```

This logic feeds:
- Bell icon list (attention items).
- Daily Report sections (“Clients I need to contact”, “Blocked projects”, “Ready for pickup but not collected”).

Also note:  
When conditions clear (ex: stock bought, client collected), underlying project stage changes and `evaluate_notifications_for_project()` will mark previous notifications `auto_cleared=True`.

---

### 3.6 Daily Report Generator (07:30, plus manual trigger)

#### Requirement
At 07:30 SAST daily (UTC+02:00), generate a full operational brief.  
Also allow a “Generate Now” button in Reports.

The Daily Report must include:
1. What needs to be cut today  
   - Approved jobs ready to cut
   - Required material for each
2. What material needs to be ordered  
   - Any InventoryItem where `count < min_required`
   - Any Project in `WaitingOnMaterial`
3. Which clients need to be notified  
   - “Ready for pickup”
   - “Quotes and Approval” overdue
   - etc.
4. Blocked projects  
   - Stage
   - What’s missing
   - Next action

The report must:
- Be visible in-app under Reports.
- Be exportable immediately as plain `.txt` for forwarding to management.
- Push highlights to Bell / Dashboard.

#### Implementation draft

**File:** `app/reports/daily_report.py`

```python
from datetime import datetime
from app.models import Project, InventoryItem, Notification, DailyReport, db

def generate_daily_report():
    """
    Build a human-readable snapshot and persist it.
    This runs at 07:30 SAST daily and can also run on-demand.
    """

    now = datetime.utcnow()

    # 1. Jobs ready to cut today
    # We define "ReadyToCut" as stage either Cutting or a pre-stage where material is confirmed available.
    ready_projects = Project.query.filter(Project.stage.in_(["Cutting", "ReadyToCut"])).all()

    # 2. Materials to order
    low_stock_items = InventoryItem.query.filter(InventoryItem.count < InventoryItem.min_required).all()
    blocked_projects = Project.query.filter(Project.stage == "WaitingOnMaterial").all()

    # 3. Clients to notify
    attention_notifications = Notification.query.filter_by(resolved=False).all()
    # We'll later filter down to only those that are client-facing.

    # 4. Stalled / overdue / blocked
    stalled_projects = Project.query.filter(Project.stage.in_([
        "QuotesAndApproval", "WaitingOnMaterial", "Cutting"
    ])).all()

    # Compose plain text body
    lines = []
    lines.append(f"DAILY REPORT {now.date().isoformat()} (Generated {now.isoformat()} UTC)")
    lines.append("")
    lines.append("WHAT NEEDS TO BE CUT TODAY:")
    for p in ready_projects:
        lines.append(f"- {p.name} (Client {p.client_id}) needs {p.material_type} {p.thickness_mm}mm {p.sheet_size}")

    lines.append("")
    lines.append("WHAT MATERIAL NEEDS TO BE ORDERED:")
    for item in low_stock_items:
        lines.append(f"- {item.material_type} {item.thickness_mm}mm {item.sheet_size}: {item.count} sheets in stock (< {item.min_required} min)")
    for p in blocked_projects:
        lines.append(f"- BLOCKED: {p.name} waiting on {p.material_type} {p.thickness_mm}mm {p.sheet_size}")

    lines.append("")
    lines.append("CLIENTS TO NOTIFY:")
    for n in attention_notifications:
        if n.notif_type in ["approval_wait", "pickup_wait"]:
            lines.append(f"- {n.message}")

    lines.append("")
    lines.append("BLOCKED / STALLED PROJECTS:")
    for p in stalled_projects:
        lines.append(f"- {p.name} ({p.stage}) :: needs action to unblock")

    report_text = "\n".join(lines)

    # Persist to DB so Reports page can show history + offer download
    daily = DailyReport(
        created_at=now,
        report_text=report_text
    )
    db.session.add(daily)
    db.session.commit()

    # Return the plain text body so caller can also export .txt immediately
    return report_text
```

**Cron / scheduler note (Windows host assumption):**
- We add an internal scheduler thread when the Flask app boots (Section 11).
- At 07:30 Africa/Johannesburg every day, call `generate_daily_report()`, store result in DB, and write `/mnt/data/DailyReport_YYYY-MM-DD.txt` for download.

**Manual trigger route:**

```python
# app/reports/routes.py (excerpt)
from flask import Blueprint, send_file
from app.reports.daily_report import generate_daily_report
from datetime import datetime

reports_bp = Blueprint("reports", __name__, url_prefix="/reports")

@reports_bp.route("/daily/generate", methods=["POST"])
def manual_generate_daily():
    txt = generate_daily_report()
    filename = f"/mnt/data/DailyReport_{datetime.utcnow().date().isoformat()}.txt"
    with open(filename, "w", encoding="utf-8") as f:
        f.write(txt)
    return send_file(filename, as_attachment=True, download_name="DailyReport.txt")
```

This satisfies:
- Auto-generate at 07:30.
- Manual “Generate Daily Report Now.”
- Export as plain `.txt`.

We’ll finalize DB models (`DailyReport`, `Notification`) in Section 4.

---

### 3.7 Notifications (Bell Icon)

#### Requirement
The bell icon shows “attention list” items:
- Stage overdue (QuotesAndApproval >4 days, etc.)
- Low stock
- Job waiting on material
- Job ready for pickup
- Client follow-up required

Behavior rules:
- You can manually clear them.
- They also auto-clear when the underlying condition resolves (stage changes, stock received, etc.).
- Each notification links to a specific Project or InventoryItem so you know what to act on.

#### Server-side structure

```python
class Notification(db.Model):
    __tablename__ = "notifications"

    id = db.Column(db.Integer, primary_key=True)

    project_id = db.Column(db.Integer, db.ForeignKey("projects.id"), nullable=True)
    inventory_item_id = db.Column(db.Integer, db.ForeignKey("inventory_items.id"), nullable=True)

    notif_type = db.Column(db.String(50), nullable=False)
    # e.g. "approval_wait", "material_block", "cutting_stall", "pickup_wait", "low_stock"

    message = db.Column(db.String(500), nullable=False)

    resolved = db.Column(db.Boolean, nullable=False, default=False)
    auto_cleared = db.Column(db.Boolean, nullable=False, default=False)

    created_at = db.Column(db.DateTime, nullable=False)
    resolved_at = db.Column(db.DateTime, nullable=True)
```

#### Bell dropdown route

```python
# app/notifications/routes.py
from flask import Blueprint, render_template, request, redirect, url_for
from datetime import datetime
from app.models import Notification, db

notifications_bp = Blueprint("notifications", __name__, url_prefix="/notifications")

@notifications_bp.route("/list", methods=["GET"])
def list_notifications():
    notes = (
        Notification.query
        .filter_by(resolved=False)
        .order_by(Notification.created_at.desc())
        .all()
    )
    return render_template("partials/bell_dropdown.html", notes=notes)

@notifications_bp.route("/resolve", methods=["POST"])
def resolve_notification():
    notif_id = request.form.get("notif_id")
    n = Notification.query.get_or_404(notif_id)
    n.resolved = True
    n.resolved_at = datetime.utcnow()
    db.session.add(n)
    db.session.commit()
    return redirect(url_for("notifications.list_notifications"))
```

Front-end:
- Dashboard header shows bell icon.
- Clicking it loads `/notifications/list` into a dropdown/overlay.
- Each entry links to `/projects/<id>` or `/inventory/<id>` as appropriate.

---

### 3.8 Communications Drafts

#### Requirement
When the system detects something overdue that requires a client message, it should:
- Create a draft message automatically.
- Store it in Communications.
- Example:
  - QuotesAndApproval too long → “Hi [ClientName], just checking in on Quote #[ref]…”
  - ReadyForPickup → “Hi [ClientName], your order is ready for pickup…”

These drafts are visible for review and can be sent via your chosen channel.

#### Draft model + generator

```python
class OutboundDraft(db.Model):
    __tablename__ = "outbound_drafts"

    id = db.Column(db.Integer, primary_key=True)
    project_id = db.Column(db.Integer, db.ForeignKey("projects.id"), nullable=False)
    client_id = db.Column(db.Integer, db.ForeignKey("clients.id"), nullable=False)

    channel_hint = db.Column(db.String(20), nullable=False, default="whatsapp")
    # "whatsapp", "email", etc.

    body_text = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False)
    sent = db.Column(db.Boolean, nullable=False, default=False)
    sent_at = db.Column(db.DateTime, nullable=True)

# app/comms/drafts.py
from datetime import datetime
from app.models import OutboundDraft, db

def build_client_followup_message(project, stage):
    if stage == "QuotesAndApproval":
        msg = (
            f"Hi {project.client.name}, just checking in on your quote for "
            f"{project.name}. We’re ready to proceed as soon as you approve. "
            f"Would you like us to go ahead?"
        )
    elif stage == "ReadyForPickup":
        msg = (
            f"Hi {project.client.name}, your order '{project.name}' is ready "
            f"for pickup/delivery. Please let us know what time suits you."
        )
    else:
        msg = (
            f"Hi {project.client.name}, quick update on '{project.name}'. "
            f"Please contact us regarding next steps."
        )

    draft = OutboundDraft(
        project_id=project.id,
        client_id=project.client_id,
        body_text=msg,
        channel_hint="whatsapp",
        created_at=datetime.utcnow()
    )
    return draft
```

The Communications section UI lists unsent drafts in reverse chronological order, lets you copy/send, and then mark as sent (`sent=True`).

---

## 4. Database Schema Changes

This section defines/solidifies all tables and relationships mentioned above, including new models, new fields, and migration notes.

### 4.1 Models Overview

We will maintain and/or introduce the following models (some likely already exist in partial form in current Laser OS; we are formalizing the required fields to match this spec):

- `User`
- `ExtraOperator`
- `Project`
- `LaserRun`
- `InventoryItem`
- `Notification`
- `DailyReport`
- `OutboundDraft`

Plus existing core entities:
- `Client`
- (Others already present: `Quote`, `Invoice`, `QueueItem`, etc.)

### 4.2 SQLAlchemy models (full definitions)

```python
# app/models.py
from app.extensions import db
from datetime import datetime

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)

    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    role = db.Column(db.String(50), nullable=False, default="operator")  
    # allowed: "operator", "manager", "admin"

    is_active_operator = db.Column(db.Boolean, nullable=False, default=True)

    display_name = db.Column(db.String(120), nullable=False)

    runs = db.relationship("LaserRun", back_populates="operator", lazy="dynamic")

    def authenticate(username, password):
        # Must verify password_hash <-> password
        # Return User instance or None
        ...

class ExtraOperator(db.Model):
    __tablename__ = "extra_operators"
    id = db.Column(db.Integer, primary_key=True)
    display_name = db.Column(db.String(120), nullable=False)
    active = db.Column(db.Boolean, nullable=False, default=True)

class Client(db.Model):
    __tablename__ = "clients"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    contact_number = db.Column(db.String(50), nullable=True)
    contact_email = db.Column(db.String(200), nullable=True)

    projects = db.relationship("Project", back_populates="client", lazy="dynamic")

class Project(db.Model):
    __tablename__ = "projects"
    id = db.Column(db.Integer, primary_key=True)

    client_id = db.Column(db.Integer, db.ForeignKey("clients.id"), nullable=False)
    client = db.relationship("Client", back_populates="projects")

    name = db.Column(db.String(200), nullable=False)

    # Project lifecycle stage
    stage = db.Column(db.String(50), nullable=False, default="QuotesAndApproval")
    stage_last_updated = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)

    # Material requirements
    material_type = db.Column(db.String(80), nullable=False)
    thickness_mm = db.Column(db.String(10), nullable=False)
    sheet_size = db.Column(db.String(32), nullable=False)
    sheets_required = db.Column(db.Integer, nullable=False, default=0)

    # Scheduling / promises
    target_complete_date = db.Column(db.DateTime, nullable=True)

    # Relationship to production runs
    runs = db.relationship("LaserRun", back_populates="project", lazy="dynamic")

class LaserRun(db.Model):
    __tablename__ = "laser_runs"
    id = db.Column(db.Integer, primary_key=True)

    project_id = db.Column(db.Integer, db.ForeignKey("projects.id"), nullable=False)
    project = db.relationship("Project", back_populates="runs")

    operator_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
    operator = db.relationship("User", back_populates="runs")

    # Timing
    started_at = db.Column(db.DateTime, nullable=False)
    ended_at = db.Column(db.DateTime, nullable=True)

    status = db.Column(db.String(20), nullable=False, default="running")
    # "running", "completed"

    # Material usage captured at end of run
    material_type = db.Column(db.String(80), nullable=False)
    thickness_mm = db.Column(db.String(10), nullable=False)
    sheet_size = db.Column(db.String(32), nullable=False)
    sheets_used = db.Column(db.Integer, nullable=False, default=0)

    notes = db.Column(db.Text, nullable=True)

class InventoryItem(db.Model):
    __tablename__ = "inventory_items"
    id = db.Column(db.Integer, primary_key=True)

    material_type = db.Column(db.String(80), nullable=False)
    thickness_mm = db.Column(db.String(10), nullable=False)
    sheet_size = db.Column(db.String(32), nullable=False)

    count = db.Column(db.Integer, nullable=False, default=0)
    min_required = db.Column(db.Integer, nullable=False, default=0)

class Notification(db.Model):
    __tablename__ = "notifications"
    id = db.Column(db.Integer, primary_key=True)

    project_id = db.Column(db.Integer, db.ForeignKey("projects.id"), nullable=True)
    inventory_item_id = db.Column(db.Integer, db.ForeignKey("inventory_items.id"), nullable=True)

    notif_type = db.Column(db.String(50), nullable=False)
    message = db.Column(db.String(500), nullable=False)

    resolved = db.Column(db.Boolean, nullable=False, default=False)
    auto_cleared = db.Column(db.Boolean, nullable=False, default=False)

    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    resolved_at = db.Column(db.DateTime, nullable=True)

class DailyReport(db.Model):
    __tablename__ = "daily_reports"
    id = db.Column(db.Integer, primary_key=True)

    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    report_text = db.Column(db.Text, nullable=False)

class OutboundDraft(db.Model):
    __tablename__ = "outbound_drafts"
    id = db.Column(db.Integer, primary_key=True)

    project_id = db.Column(db.Integer, db.ForeignKey("projects.id"), nullable=False)
    client_id = db.Column(db.Integer, db.ForeignKey("clients.id"), nullable=False)

    channel_hint = db.Column(db.String(20), nullable=False, default="whatsapp")
    body_text = db.Column(db.Text, nullable=False)

    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    sent = db.Column(db.Boolean, nullable=False, default=False)
    sent_at = db.Column(db.DateTime, nullable=True)
```

### 4.3 Relationships Summary
- `Client 1..* Project`
- `Project 1..* LaserRun`
- `User 1..* LaserRun`
- `Project 1..* OutboundDraft`
- `Client 1..* OutboundDraft`
- `Project 1..* Notification`
- `InventoryItem 1..* Notification` (optional link for low stock alerts)
- `DailyReport` is time-series log of generated daily briefs.

### 4.4 Migration Notes
We'll add Alembic-style migrations or manual SQLite schema migrations:
1. Add new tables: `laser_runs`, `inventory_items`, `notifications`, `daily_reports`, `outbound_drafts`, `extra_operators`.
2. Alter `projects` table:
   - Add `stage`, `stage_last_updated`, `material_type`, `thickness_mm`, `sheet_size`, `sheets_required`, `target_complete_date`.
3. Alter `users` table:
   - Add `role`, `is_active_operator`, `display_name`.

---

## 5. API Endpoints

This section defines REST-style endpoints that back the UI.

### 5.1 Auth / Mode

- `POST /auth/login`
  - Body: `username`, `password`
  - Action: authenticate, `login_user`, set `session["operator_id"]`
  - Returns: redirect → `/auth/select-mode`

- `GET /auth/select-mode`
  - Show: choose PC or Phone

- `POST /auth/select-mode`
  - Body: `mode = "pc" | "phone"`
  - Sets `session["ui_mode"]`
  - Redirects to `/dashboard` (pc) or `/phone/home` (phone)

### 5.2 Phone Mode Production Logging

- `GET /phone/home`
  - Returns list of Projects in `Cutting` or `ReadyToCut`
  - Minimal UI

- `POST /phone/run/start`
  - Body: `project_id`
  - Creates `LaserRun` with `status="running"`, `started_at=now`, ties to `current_user.id`.
  - Forces project.stage = "Cutting", updates `stage_last_updated`.

- `GET /phone/run/<run_id>`
  - Returns a view with active run data and an “End Run” button.

- `POST /phone/run/end`
  - Body: `run_id`, `sheets_used`, `notes`
  - Sets `ended_at`, `status="completed"`
  - Calls inventory deduction
  - Refreshes reporting + notifications

### 5.3 Inventory

- `GET /inventory`
  - Shows all InventoryItem rows, including:
    - material_type
    - thickness_mm
    - sheet_size
    - count
    - min_required
    - low-stock warning flag

- `POST /inventory/add`
  - Body: `material_type`, `thickness_mm`, `sheet_size`, `count`, `min_required`
  - Creates InventoryItem

- `POST /inventory/update`
  - Body includes InventoryItem.id and updated counts
  - Used after receiving new sheets

### 5.4 Notifications (Bell)

- `GET /notifications/list`
  - Returns unresolved notifications
  - Used in header dropdown

- `POST /notifications/resolve`
  - Body: `notif_id`
  - Marks resolved, sets `resolved_at`

### 5.5 Reports

- `GET /reports/daily`
  - Shows latest DailyReport plus download link

- `POST /reports/daily/generate`
  - Triggers `generate_daily_report()`
  - Writes `/mnt/data/DailyReport_<date>.txt`
  - Responds with file download

### 5.6 Communications Drafts

- `GET /communications/drafts`
  - Lists unsent `OutboundDraft` rows with project/client context

- `POST /communications/mark-sent`
  - Body: `draft_id`
  - Marks the draft as sent, sets `sent=True`, `sent_at=now`

---

## 6. Security & Access Control

### 6.1 Roles
- `admin`
  - Full access to Admin, Presets, Inventory editing, Reports, all Projects
- `manager`
  - Access to Dashboard, Projects, Queue, Reports, Communications, can generate Daily Report
  - Can view Inventory and low stock, but cannot edit Presets
- `operator`
  - Access to Phone Mode (run logging, view presets for job)
  - Cannot edit Presets
  - Cannot edit Inventory
  - Cannot modify project stage manually from phone

### 6.2 Decorators

We add role-based decorators in `app/security/decorators.py`:

```python
from functools import wraps
from flask_login import current_user
from flask import abort

def require_role(*allowed_roles):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            if not current_user.is_authenticated:
                return abort(401)
            if current_user.role not in allowed_roles:
                return abort(403)
            return fn(*args, **kwargs)
        return wrapper
    return decorator
```

Usage examples:
- Inventory editing routes → `@require_role("admin", "manager")` (manager can adjust counts when stock arrives)
- Preset edit routes → `@require_role("admin")`
- Phone Mode run log routes → `@require_role("operator", "manager", "admin")`

### 6.3 Data binding
- `session["operator_id"]` is always set on login.
- LaserRun rows always tie to that ID.
- This guarantees auditability per operator.

---

## 7. UI / UX Changes

### 7.1 Global

- Replace browser favicon with the provided `@laser-cutting-machine` image.
  - Add `static/img/laser-cutting-machine.ico` (converted to .ico)
  - In `templates/base.html`:
    ```html
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='img/laser-cutting-machine.ico') }}">
    ```

- Dashboard header shows:
  - Logged-in profile (display_name + role)
  - Bell icon with count of unresolved notifications
  - Clicking bell makes AJAX call to `/notifications/list`

### 7.2 PC Mode Layout

Sidebar tabs (per spec):
- Dashboard
- Clients
- Projects
- Products
- Queue
- Presets
- Operators
- Inventory
- Reports
- SAGE
- Communications
- Admin

Dashboard surface cards:
- “Low Stock”
- “Waiting on Client Approval”
- “Ready for Pickup”
- “Blocked by Material”
These are sourced from Notifications and DailyReport highlights.

### 7.3 Phone Mode Layout

Goals:
- Fast.
- Chunky tap targets.
- Zero clutter from admin/finance.

Screens:
1. **/phone/home**
   - List active jobs:
     - Project name
     - Client
     - Required material/thickness/sheet size
     - Button: “Start Run”
   - Each list item is thumb-sized card.

2. **/phone/run_active**
   - Shows:
     - Project name
     - Preset reference (read-only preset parameters for the chosen thickness)
     - “End Run” big button
   - End Run form collects:
     - Sheets used (number stepper)
     - Notes/issues (optional text)
   - Submit posts to `/phone/run/end`

3. Presets display
   - Read-only panel of the preset mapped to this project’s thickness.
   - Operator can visually check against machine (CypCut).
   - No edit button.

We’ll style Phone Mode with a separate base template, e.g. `templates/phone/base_phone.html`, using large buttons and minimal nav.

---

## 8. Testing Plan

### 8.1 Unit tests
- `test_inventory_deduction.py`
  - Create InventoryItem(count=6)
  - Create LaserRun(sheets_used=2)
  - Call `apply_run_inventory_deduction(run)`
  - Assert new count == 4

- `test_stage_escalation.py`
  - Create Project(stage="QuotesAndApproval", stage_last_updated=now-5days)
  - Call `evaluate_notifications_for_project()`
  - Assert Notification with `notif_type="approval_wait"` created
  - Assert OutboundDraft created with correct message to client

- `test_daily_report_generation.py`
  - Seed:
    - Project in ReadyToCut
    - InventoryItem under min_required
    - Project in WaitingOnMaterial
    - Notification("pickup_wait")
  - Call `generate_daily_report()`
  - Assert text contains all four sections

- `test_role_enforcement.py`
  - Fake user with role "operator" calls inventory edit route → expect 403
  - "admin" succeeds

### 8.2 Integration tests
- Full Phone Mode flow:
  - Login as operator
  - Select Phone Mode
  - Start run on project
  - End run with sheets_used=3
  - Confirm:
    - LaserRun completed
    - Inventory count reduced by 3
    - Project.stage updated (Cutting with new timestamp)
    - DailyReport can now list that job in Production Summary

### 8.3 Acceptance tests
- Generate Daily Report via button, download .txt.
- Bell icon shows overdue quote follow-up.
- Communications tab shows draft WhatsApp message for that client.

---

## 9. Error Handling

### 9.1 Inventory underflow
If sheets_used > available stock:
- Deduct down to zero (already enforced with `max(inv_row.count - used_sheets, 0)`).
- Also create a `Notification` with `notif_type="low_stock"` so management sees emergency buy requirement.

### 9.2 Missing preset
If Project has a thickness with no preset defined:
- Phone Mode run_active page should still allow run logging (production cannot be blocked mid-shift),
- but UI must display a red warning: “No preset found for {thickness_mm}mm. Check CypCut manually.”
- Also generate a Notification type `"preset_missing"` for admin.

### 9.3 Stage mismatch
If operator starts a run on a Project that is not in `Cutting` or `ReadyToCut`, server will still force `project.stage = "Cutting"` and timestamp it. No crash. Production comes first.

---

## 10. Performance & Scaling

### 10.1 SQLite considerations
- Use indexed columns on:
  - `projects.stage`
  - `inventory_items.material_type`, `inventory_items.thickness_mm`, `inventory_items.sheet_size`
  - `notifications.resolved`
  - `laser_runs.project_id`, `laser_runs.operator_id`

```python
# example Alembic/SQL snippet for index
op.create_index('idx_projects_stage', 'projects', ['stage'])
op.create_index('idx_inventory_material_combo', 'inventory_items', ['material_type','thickness_mm','sheet_size'])
op.create_index('idx_notifications_resolved', 'notifications', ['resolved'])
op.create_index('idx_runs_project', 'laser_runs', ['project_id'])
op.create_index('idx_runs_operator', 'laser_runs', ['operator_id'])
```

### 10.2 Report generation
- Daily Report is lightweight text aggregation. We store the generated string once per day in `daily_reports`.
- UI for Reports should display only the latest by default and lazy-load older ones.

### 10.3 Notification churn
- We auto-clear old notifications when calling `evaluate_notifications_for_project()`. This prevents unbounded growth of unresolved items.

---

## 11. Deployment & Migration Steps

### 11.1 DB migration
1. Add/alter tables and columns defined in Section 4.
2. Run migration script to backfill:
   - For existing Projects:
     - Set `stage="QuotesAndApproval"`
     - Set `stage_last_updated=datetime.utcnow()`
   - For existing Users:
     - Set `role="admin"` for Garrison or other managers.
     - Set `role="operator"` for normal machine operators.
     - Populate `display_name` with existing name field.

### 11.2 Scheduler for Daily Report (07:30 SAST)
We add a background scheduler thread when Flask starts. Since we’re on local infra, we can embed APScheduler-style logic or a custom loop thread.

**File:** `app/scheduler/daily_job.py`

```python
import threading, time
from datetime import datetime, timedelta
import pytz
from app import create_app
from app.reports.daily_report import generate_daily_report
from app.extensions import db

TZ = pytz.timezone("Africa/Johannesburg")

def _seconds_until_next_0730():
    now = datetime.now(TZ)
    target = now.replace(hour=7, minute=30, second=0, microsecond=0)
    if target <= now:
        target = target + timedelta(days=1)
    return (target - now).total_seconds()

def scheduler_loop(app):
    with app.app_context():
        while True:
            wait_s = _seconds_until_next_0730()
            time.sleep(wait_s)

            # Run the generator, persist in DB, and write txt file
            txt = generate_daily_report()
            filename = f"/mnt/data/DailyReport_{datetime.utcnow().date().isoformat()}.txt"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(txt)

def start_scheduler(app):
    t = threading.Thread(target=scheduler_loop, args=(app,), daemon=True)
    t.start()

# In app/__init__.py after app is created:
# from app.scheduler.daily_job import start_scheduler
# start_scheduler(app)
```

This guarantees automatic generation at 07:30 Africa/Johannesburg daily.

### 11.3 Favicon
- Convert provided `@laser-cutting-machine` image to `.ico`.
- Place in `static/img/laser-cutting-machine.ico`.
- Update `templates/base.html` head tag.

### 11.4 Rollout steps
1. Apply DB migrations.
2. Deploy updated Flask app with scheduler active.
3. Log in, choose PC Mode, verify sidebar.
4. Log in again, choose Phone Mode, run start/end flow.
5. Check:
   - Inventory deduction works.
   - Bell shows new alerts.
   - Reports → Daily Report → Generate Now works + downloads .txt.

---

## 12. Integration Notes

### 12.1 Auto-Queue on POP Received
No changes required to trigger the queue, but:
- Queue items must now include required material fields (`material_type`, `thickness_mm`, `sheet_size`, `sheets_required`) so we can pre-check stock and warn if job will be blocked.
- When queue promotes a job to “ReadyToCut”, we should:
  - Validate stock
  - If stock missing → do NOT say ReadyToCut; instead set Project.stage="WaitingOnMaterial"
  - Create Notification `"material_block"`

### 12.2 Queue-Project Status Sync
When Queue moves an item forward to “Cutting,” update `Project.stage = "Cutting"` and reset `stage_last_updated`.

If Queue shows job is fully cut, set:
- `Project.stage = "ReadyForPickup"`
- `stage_last_updated = now`
- Trigger Notification `"pickup_wait"` (client should be told)

### 12.3 Operator Auto-Bind
Covered by session tracking:
- After login, `session["operator_id"] = user.id`.
- All `/phone/*` run logs automatically bind operator_id.

### 12.4 Presets attachment
When a Project is created and assigned a thickness, the system:
- Looks up Preset by `(material_type, thickness_mm)`.
- Attaches preset reference to the Project record (e.g. `project.preset_id`).
- That preset gets displayed in Phone Mode run_active view.

Operators can view but not modify presets:
- Phone mode template excludes any edit buttons.
- Preset edit routes are protected by `@require_role("admin")`.

---

## 13. Documentation Checklist

The following internal docs must be updated or created so that future admins, operators, and AI agents can maintain consistency:

- `docs/login_and_mode_selection.md`
  - Screenshots of login → select mode → PC vs Phone.
  - Clarify operator identity follows session.

- `docs/phone_mode_run_logging.md`
  - How to Start Run / End Run.
  - How sheets_used affects inventory.

- `docs/inventory_management.md`
  - Rules for sheet tracking.
  - Thickness list source-of-truth (`app/constants/material_thickness.py`).
  - How low-stock triggers Notifications and Daily Report.

- `docs/project_stages_and_alerts.md`
  - Stage definitions.
  - Escalation timing (4 days approval, etc.).
  - How notifications get auto-cleared.

- `docs/daily_report.md`
  - Auto-run at 07:30 SAST.
  - Manual Generate button in Reports.
  - Location of exported .txt in `/mnt/data`.

- `docs/presets_control.md`
  - How presets are managed centrally.
  - Why operators cannot edit.
  - How preset is auto-attached based on thickness.

- `docs/communications_outbound.md`
  - How draft messages are generated.
  - How to mark as sent.

- `docs/favicon_branding.md`
  - How to update the favicon to the laser-cutting-machine icon.

All docs must include explicit instructions without placeholders and reflect the live field names and route names defined in this blueprint.

---

## 14. Implementation Status Tracker

Use this checklist to track progress as features are implemented and verified in staging, then production.

| Area                                                            | Files / Tables / Routes touched                                                                                                      | Status |
|-----------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|--------|
| Login + Mode Selector (PC / Phone)                              | `auth/routes.py`, `templates/auth/select_mode.html`, session keys `ui_mode`, `operator_id`                                          | [ ]    |
| Phone Mode UI + Run Start/End                                   | `phone/routes.py`, `templates/phone/home.html`, `templates/phone/run_active.html`                                                   | [ ]    |
| Operator binding to User                                        | `User` model updates, session tracking, `LaserRun.operator_id`                                                                      | [ ]    |
| ExtraOperator support                                           | `ExtraOperator` model                                                                                                               | [ ]    |
| Inventory sheet tracking + deduction on run complete            | `InventoryItem` model, `production/logic.py::apply_run_inventory_deduction`                                                         | [ ]    |
| Global thickness list constant                                  | `app/constants/material_thickness.py`, all relevant forms                                                                           | [ ]    |
| Project stage fields + timing                                   | `Project.stage`, `Project.stage_last_updated`, escalation limits in `notifications/logic.py`                                        | [ ]    |
| Notification system (bell)                                      | `Notification` model, `notifications/routes.py`, dashboard bell dropdown                                                            | [ ]    |
| Auto-clear / regenerate notifications                           | `evaluate_notifications_for_project()`                                                                                              | [ ]    |
| Communications drafts (auto-generated client messages)          | `OutboundDraft` model, `comms/drafts.py`, `communications` UI                                                                       | [ ]    |
| Daily Report generation + .txt export                           | `DailyReport` model, `reports/daily_report.py`, `reports/routes.py:/daily/generate`                                                 | [ ]    |
| Daily scheduler 07:30 SAST                                      | `scheduler/daily_job.py`, `app/__init__.py` integration                                                                             | [ ]    |
| Reports pages populated (Production Summary, Efficiency, etc.)  | `reports/updater.py`, queries against `LaserRun`, `Project`, `InventoryItem`                                                        | [ ]    |
| Dashboard surface cards (what needs attention)                  | Dashboard template pulls from Notifications + latest DailyReport                                                                    | [ ]    |
| Preset auto-attach + read-only in Phone Mode                    | Preset lookup by `(material_type, thickness_mm)`, store preset_id in Project, render in phone run view, no edit in phone            | [ ]    |
| Favicon / branding                                              | `static/img/laser-cutting-machine.ico`, `templates/base.html`                                                                       | [ ]    |
| Role-based access decorators                                    | `security/decorators.py`, applied to Inventory edit, Preset edit, Phone Mode, Reports generation                                   | [ ]    |
| DB migrations                                                   | Add `laser_runs`, `inventory_items`, `notifications`, `daily_reports`, `outbound_drafts`, `extra_operators`; alter `users`, `projects` | [ ]    |


---

### END OF BLUEPRINT

All required behavioral rules from your spec (operator login identity, phone mode logging, preset locking, sheet-based stock tracking, stage escalation, bell notifications, Daily Report @07:30, comms drafts) are now mapped to code, models, routes, scheduler, and UI.

This file can now be handed directly to a developer or an AI agent inside `c:\Users\Garas\Documents\augment-projects\full_dxf_laser_buisness` to begin implementation.
